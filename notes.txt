Blog post: https://realpython.com/blog/python/token-based-authentication-with-flask/

Token-Based Auth with Flask

Obectives
  By the end of this tutorial you will be able to...

    1. Discuss the benefits of using JWTs vs sessions and cookies for authentication
    2. Implement user authentication with JWTs
    3. Blacklist user tokens when necessary
    4. Write tests to create and verify JWTs and add user authentication
    5. Practive test-driven development

Introduction
  JSON Web Tokens (or JWTs) provide a means of transmitting information from the client to the server in a stateless, secure way.

  On the server, JWTs are generated by signing user information via a secret key, which are then securely stored on the client. This form of auth works well with modern, single page applications. For more on this, along with the pros and cons of using JWTs vs. session and cookie-based auth, please read the following articles:
    * some articles

  Note: Keep in mind that since a JWT is signed rather than encryted it should never contain sensitive information like a user's password.

Getting Started
  Project Setup
    Start by cloning the project boilerplate and then create a new branch:

      <clone>

    Create and active a virtualenv and install the dependencies:

      $ python3.6 -m venv env
      $ source env/bin/activate
      (env)$ pip install -r requirements.txt

    This is optional, but it's a good idea to create a new GitHub repo and update the remote.

  Database Setup
    Let's set up Postgres.

    Note: If you're on a Mac, check out Postgres app.

    export path (need to automate this)
    ************************************
    export PATH="/Applications/Postgres.app/Contents/Versions/latest/bin:$PATH"

    Once the Postgres server is running, create two new databases from psql that share the same name as your project name:

      (env)$ psql
      # create database flask_jwt_auth;
      CREATE DATABASE
      # create database flask_jwt_auth_test;
      CREATE DATABASE
      # \q

    Before applying the database migrations we need to update the config file found in project/server/config.py. Simply update the database_name:

      database_name = 'flask_jwt_auth'

    Set the environment variables in the terminal:

      (env)$ export APP_SETTINGS="project.server.config.DevelopmentConfig"

    Update the following test in project/tests/test__config.py:


JWT Setup
  The auth workflow works as follows:
    * Client provides email and password, which is sent to the server
    * Server then verifies that email and password are correct and responds with an auth token
    * Client stores the token and sends it along with all subseuent requests to the API
    * Server decodes the token and validates it

  The cycle repeats until the token expires or is revoked. In the latter case, the server issues a new token.

  The token themselves are divided into three parts:
    * Header
    * Payload
    * Signature

  We'll dive a bit deeper into the payload, but if you're curious, you can read more about each part in the Intro to JSON Web Tokens article.

  To work with JSON Web Tokens in our app, insatl the PyJWT package:

    (env)$ pip install pyjwt==1.4.2
    (env)$ pip freeze > requirements.txt

  Encode token
    Add the following method to the User() class in project/server/models.py

    def encode_auth_token(self, user_id):
      ...

    Don't forget the import jwt

  So, given a user id, this method creates and returns a token from the payload and hte secrete key set in the config.py file. The payload is where we add metadata about the token and information about the user. This information is often referred to as the JWT Claims. We utilize the following 'claims':
    * exp: expiration date of the token
    * iat: the time the token is generated
    * sub: the subject of the token

  The secret key must be random and only accessable server-side. Use the Python interpreter to generate a key:

    (env)$ python
    >>> import os
    >>> os.urandom(24)
    b"...""
    >>>

  Set the key as an environment variable:

    (env)$ export SECRET_KEY="..."

  Decode Token
    Similarly, to decode a token, add the following method to the User() class:

      @staticmethod
      def decode_auth_token(auth_token):
        ...

    We need to decode the auth token with every API request and verify its signature to be sure of the user's authenticity. To verify the auth_token, we use the same SECRET_KEY used to encode a token.

    If the auth_token is valid, we get the user id from the sub index of the payload. If invalid, there could be two exceptions.

      1. Expired Signature When the token is used after it's expired, it throws a ExpiredSignatureError exception. This means the time specified in the payload's exp field has expired.

      2. Invalid Token: When the token supplied is not correct or malformed, then an InvalidTokenError exception is raised.

    Note: We have used a static method since it does not relate to the class' instance.

